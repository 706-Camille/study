###  agile software development principles patterns and practices를 읽고 정리한 내용이다
------------------------------
#### 이 책은 세 가지 주제인 ***principles, patterns, practices***를 다룬다.
1. principle은 진리이다. 이것은 추구할 이상이자, 지향할 목표다. 하지만 따라야 할 규칙도 아니고 지켜야 할 법칙도 아니다. 이 원칙을 적용할 시기와 위치를 스스로 판단해야 한다.
2. 패턴은 문제에 대한 '해결책'이다. 이 해결책들은 특정 상황에서는 적절하지만, 그 외의 상황에서는 그렇지 못하다. 이 지식은 각자의 지성에 의해 적용되어야 한다. 패턴은 좋은 것도 나쁜 것도 아니다.
3. 실천방법은 소프트웨어의 품질과 생산성을 향상하는 '행동 양식'이다. 팀 멤버들이 팀원 서로에게, 그리고 업무에 대해, 또 그들이 만든 코드에 대해 어떻게 행동해야 하는지를 나타낸다.
-----------------------------------------------
#### agile practice (애자일 실천방법)
----------------------------------------------------
1. 프로세스와 툴보다 개인과 상호작용이 우선이다.
   - 팀을 구성하는 일은 환경을 구축하는 일보다 더 중요하다
   - 알맞은 툴은 성공을 위해 매우 중요하다. 그러나 툴이 지나치게 강조되는 경우도 있다. 거대하고 통제할 수 없는 툴이 넘쳐나는 상황은 툴이 부족한 상황만큼이나 좋지 않다.
     
2. 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.
   - 문서화되어 있지 않는 소프트웨어는 재앙이다.
   - 그러나 지나친 문서화는 안 하느니만 못하다. 작성할 때 엄청난 시간을 들여야 할 뿐만 아니라 코드와 동기화를 유지하는 데는 더 많은 시간이 소모된다.
   - 설계 원리와 구조에 대한 문서를 쓰고 유지하는 것은 바람직하지만, 그 문서는 짧고 요약적이어야 한다.
   - 마틴의 문서화 제 1법칙 : 그 필요가 급박하고 중요하지 않다면 아무 문서도 만들지 마라.
     
3. 계약 협상보다 고객 협력이 우선이다.
   - 성공적인 프로젝트를 위해서는 규칙적으로 자주 고객의 피드백을 받아야 한다.
   - 계약서나 작업기술서에 의존하기보다는 개발 팀의 노력의 결과에 자주 피드백을 주면서, 소프트웨어의 고객이 개발 팀과 가까이서 일한다.
     
4. 계획을 따르는 것보다 변화에 대한 반응이 우선이다.
   - 종종 소프트웨어 프로젝트의 성공과 실패를 좌우하는 것은 변화에 대한 반응 능력이다.
   - 소프트웨어의 프로젝트의 과정은 먼 미래까지 계획될 수가 없다. 무엇보다도 업무 환경은 변하기 쉽고, 그것은 고객의 요구사항을 변하게 만든다. 모든 것이 예상대로 돌아가지는 않는다.
   - 바람직한 계획 전략은 다음 2주간의 세부적인 계획을 수립하고, 다음 3개월간의 개략적인 계획을, 그 이후로는 아주 대강의 계획을 세우는 것이다.
   - 계획은 몇 주간의 시간만 통제할 뿐이고, 계획의 나머지 부분은 탄력적으로 조정할 수 있다.

-----------------------------------------------------
#### principle (원칙)
------------------------------------------------
##### 앞서 설명한 가치들은 다음과 같은 열두 가지 원칙을 이끌어낸다.
- 우리의 최고 가치는 유용한 소프트웨어의 "빠르고 지속적인 공개"를 통해 고객을 만족시키는 것이다. ( 고객과 지속적인 협력을 통해 고객의 요구를 만족하는 것 ( 기능성을 계속 높여가면서 수시로 공개했을때 최종 품질과 비례관계를 보였다)  
- 개발 후반부에 접어들었다 할지라도, 요구사항 변경을 환영하라. 애자일 프로세스는 고객의 경쟁 위으를 위해 변화를 이용한다. (태도의 선언, 구조를 탄력적으로 유지하기 위해 노력, 따라서 요구사항이 변경됐을 때 시스템에 미치는 영향을 최소화 한다.)  
- 개발 중인 소프트웨어를 2주에서 2달 사이, 혹은 더 짧은 시간 간격으로 자주 공개하라. (빠른 공개로, 피드백 후 보완)  
- 업무를 하는 사람과 개발자는 프로젝트를 통틀어 계속 함께 일해야 한다. (상호작용이 중요하다)  
- 의욕적인 개인들을 중심으로 프로젝트를 구성하라. 환경과 필요로 하는 지원을 제공하고, 그들이 일을 해낼 것이라 믿고 맡겨둬라. (사람이 성공의 가장 중요한 요소이다)  
- 개발 팀 내에서 정보를 전달하고 공유하는 가장 효율적이고 효과적인 방법은 직접 일대일로 대화하는 것이다. (문서는 필수적인 것이 아니다. 일대일 대화가 보다 효율적인 의사소통 방식이다)  
- 개발 중인 소프트웨어가 진척 상황의 일차적 척도다. (진척상황은 진행하고 있는 단계나 작성한 문서의 양, 또는 작성한 기반구조 코드의 양으로 측정하는 것이 아니다)  
- 애자일 프로세스는 지속 가능한 개발을 촉진한다. 스폰서, 개발자, 그리고 사용자는 무한히 지속적인 pace를 유지할 수 있어야 한다.  
- 우수 기술과 좋은 설계에 대한 지속적인 관심은 속도를 향상한다. (프로젝트를 빠르게 진행하는 방법은 소프트웨어를 가능한 한 깨끗하고 튼튼한 상태로 유지하는 것이다)  
- 단순성(아직 끝내지 않은 일의 양을 최대화하는 예술)은 필수적이다.  
- 최고의 아키텍처, 요구사항, 그리고 설계는 자기 조직적인 팀에서 나온다. (팀원들은 모든 분야에서 함께 일하고. 각 팀원이 전체 분야에 참여한다. 팀원 한 명이 아키텍처나 요구사항, 또는 테스트를 담당하는 것이 아니라, 팀 전체가 이 책임을 공유한다.)  
- 규칙적으로 팀은 좀 더 효과적인 방법을 반영해야 하고, 적절히 그 행위를 조율하고 조정해야 한다.
##### 결론
_모든 소프트웨어 개발자와 모든 개발 팀의 직업적 목표는 그들의 고용인과 고객에게 가능한한 가장 높은 가치를 전달하는 것이다._
-------------------------------------------------------------------------------

##### Extreme Programming 실천방법
1. 고객 팀 구성원
  - XP 프로젝트에서 고객이 누구든 간에 팀의 멤버이며, 팀에서 일할 수 있다.
  - 고객에게 있어 최선의 상황은 개발자와 같은 공간에서 일하는 것이다.
2. 사용자 스토리
  - XP를 사용할 때는 세부 사항을 기록하지는 않는다. 그보다도 고객은 같이 합의해서 정한 색인 카드에 몇 개의 단어를 적어 그 대화 내용을 기억한다. user story란 현재 진행 중인 요구사항에 관한 대화의 연상 기호이다.
  - 이것은 우선순위와 추정 비용에 근거해 요구사항의 구현 일정을 수립하게 해주는 계획 툴이다.
3. 짧은 반복
  - XP 프로젝트는 개발 중인 소프트웨어를 2주마다 공개한다.
  - 반복 계획 : 보통 2주 단위로 진행된다. 반복 계획은 개발자가 세운 예산에 따라 고객이 선택한 사용자 스토리의 집합이다. (2 weeks sprint)
  - 릴리즈 계획 : 6번의 반복 일정을 정밀하게 표현하는 릴리즈 계획을 만든다. 릴리즈 계획은 개발자가 제시한 예산에 맞춰 고객이 선택한, 우선순위가 정해진 '사용자 스토리'의 묶음으로 구성된다.
4. 인수 테스트
  - 이 테스트는 시스템이 고객이 명시한 대로 동작하는지 여부를 검증 한다.
5. 짝 프로그래밍
  - 모든 운영(production code) 코드는 같은 워크스테이션으로 일하는 프로그래미 짝들에 의해 작성된다. 한 멤버는 키보드를 잡고 코드를 입력한다. 다른 한 멤버는 입력되는 코드를 보면서 에러와 개선점을 찾는다. (긴밀한 상호작용)
  - 한 반복 과정 동안 팀의 모든 멤버는 다른 모든 멤버와 함께 일해봐야 한다. 이런 방식은 팀 내부에서 지식이 더 빨리 확산되게 한다.
6. 테스트 주도 개발 (Test Driven Development) (4장에서 다룰 내용, 간단한 개요)
  - 모든 운영 코드는 실패하는 단위 테스트를 통과하기 위해 작성된다.
  - 해당 부분만 독립적으로 테스트하기 때문에 어떤 코드를 리팩토링하여도 빠르게 문제 여부를 확인할 수 있다.
7. 공동 소유권
  - 짝은 어떤 모듈이라도 점검하고 개선할 권리를 갖는다. XP가 전문성을 부정한다는 뜻이 아니다. 개별적인 모듈이나 기술에 대해 개인적으로 책임을 지지 않는다.
8. 지속적인 통합
  - 프로그래머는 자신의 코드를 체크인 하고 하루에 몇 번씩 그것을 통합한다. 규칙은 간단하다. 첫 번째로 체크인한 사람을 우선으로 하여 나머지 사람의 코드를 병합한다.
  - 빌드할 때마다 자동 테스트가 실행되어 통합 문제점을 일찍 찾아냅니다. 따라서 문제점을 수정하기가 더 용이합니다.
9. 지속 가능한 속도 : 꾸준한 페이스, 초과 근무 x, 유일한 예외는 릴리즈의 마지막 주

10. 열린 작업 공간 ( 소통이 원할한 환경 조성)
11. 계획 세우기 게임 (3장에서 자세히 다룰 것)
  - 업무 관련 인력(고객)은 기능 요소가 얼마나 중요한지를 결정 -> 개발자는 그 기능 요소를 구현하는 데 얼마나 비용이 들것인지를 결정.
  - 각 릴리즈와 반복을 시작할 때, 개발자는 가장 최근의 반복이나 릴리즈에서 완성할 수 있었던 양을 기준으로 예산을 세워 고객에게 제출 -> 고객은 예산을 넘지 않는 선에서 스토리를 선택
12. 단순한 설계
  - XP 팀은 그들의 설계를 가능한 한 단순하고 표현적으로 만든다
  - 한 반복에서 다음 반복으로 넘어갈 때 시스템의 설계를 마이그레이션해서, 시스템이 현재 구현하고 있는 스토리에 가장 적합한 설계가 되도록 한다.
13. 어떻게든 동작하는 가장 단순한 것을 생각한다.
  - XP팀은 현재 스토리를 구현하는 가장 간단한 방법을 생각하려고 한다. 그시로 실제로 구현할 수 있을 정도로 최대한 단순한 솔루션을 선택한다.
14. 필요하지 않을 것이라는 가정에서 시작한다.
  - 기반구조(infrastructure)가 필요하지 않을 것이라는 가정하에 프로젝트를 시작한다.
  - 아주 강한 근거가 있을 때 비로소 기반구조를 추가한다.
15. 코드를 중복해서 쓰지 않는다.
  - 중복성을 제거하는 최선의 방법은 추상화(abstraction)다.
16. 리팩토링 (5장에서 다룰 것, 간단한 개요)
  - 코드는 퇴화한다. 내버려두면 유지보수할 수 없는 엉망징창인 코드가 되어버린다.
  - XP 팀은 이런 퇴화를 잦은 리팩토링으로 방지한다.
17. 메타포 (시스템을 전체적으로 생각하는데 도움이 되는 비유??, 그림)
  - 퍼즐의 각 조각의 모양보다 더 강력한 것이 있는데, 바로 전체 그림이다. 그림에서 인접한 두 조각의 모양이 일치하지 않는다면 퍼즐을 만든 사람이 실수했다는 것까지도 알 수 있다.
  - 이것이 바로 메타포이다. 전체 시스템을 하나로 묶는 큰 그림이다. 이것은 개별적인 모듈의 위치와 형태를 명백하게 만드는 시스템의 비전이다
--------------------------------------------------------------
##### 계획 세우기
1. 초기 탐색
  - 어떤 스토리의 상대적인 비용을 표현하기 위해 스토리 카드에 그 스토리의 몇몇 포인트만 적는다
  - 대략적인 사용자 스토리를 구성해본다
2. 스파이크,분할,속도
  - 너무 크거나 작은 스토리는 추정하기 어렵다.
  - 스토리의 정확한 크기를 알기 위해서는 속도(velocity)라는 요소가 필요하다.
  - 스토리의 추정에 그 속도를 곱하여 실제 소요 시간 추정 결과를 얻어낼 수 있다.
  - 프로젝트가 진행됨에 따라 각 반복마다 완료한 스토리의 포인트 수를 측정 -> 속도는 점점 더 정확하게 측정 된다.
  - 대개, 며칠만 투자해도 한두 개의 스토리로 프로토타입을 만들어보면서 팀의 속도를 알 수 있다. 이런 프로토타입 단계를 Spike라 한다.
3. 릴리즈 계획 세우기
  - 보통 2~4달의 기간이 릴리즈 기간이다.
  - 비용의 우선순위, 스토리의 중요도 등을 토대로 업무 의사결정을 내린다.
  - 처음에는 속도가 정확하지 않기 때문에 완벽하게 계획할 수는 없다. 릴리즈 계획은 속도가 점점 더 정확해짐에 따라 조정될 수 있다.
4. 반복 계획 세우기
  - 보통 반복의 크기는 2주이다.
  - 반복 안에서 스토리 순서를 결정하는 것은 기술적인 결정이다. 개발자는 기술적으로 합리적인 순서에 따라 스토리를 구현한다.
  - 반복이 시작되면 고객은 그 반복의 스토리를 바꿀 수 없다.
  - 완료한 스토리의 추정 소요 시간을 모두 더하여, 반복의 속도를 계산한다.
  - 속도에 관한 피드백으로 팀이 계획을 잘 유지할 수 있도록 도와준다.
5. 태스크 계획 세우기
  - 태스크는 한 개발자가 4~16시간 동안 구현할 수 있는 것이다.
  - 개발자는 어떤 종류의 태스크에든 참여할 수 있다. 비효율적으로 보일 수도 있지만, 개발자가 전체 프로젝트에 더 알게 될수록 프로젝트 팀은 더욱 단단해지고 더 많은 정보를 알게 된다.
  - 각 개발자는 최근의 반복에서 구현했던 태스크 포인트가 몇 개인지 알고 있다. 이 숫자는 개인적인 예산(budget)이 된다.
6. 반환점
  - 반복이 반쯤 진행되었을때 스토리의 반이 완료되어 있지 않다면, 팀은 태스크와 책임을 재분배하여 반복이 끝날때 까지 모든 스토리를 완료해야 한다.
  - 이 과정에서 태스크의 우선순위를 통해 업무를 재조정 할 수 있다.
7. 반복
  - 2주마다 현재의 반복이 끝나고 다음 반복이 시작된다.
  - 각 반복의 마지막에는 고객에게 소프트웨어를 시연한다. 고객은 시연된 프로젝트를 통해 피드백을 제공한다.
  - 긴밀한 상호작용을 통해 진행 상황을 수시로 체크, 속도도 측정할 수 있다.
8. 결론
  - 반복에서 반복으로 릴리즈에서 릴리즈로 넘어가면서, 프로젝트는 예측 가능하고 안정적인 리듬을 찾아간다.
  - 개발자는 스스로 추정한 소요 시간에 기반하여 스스로 측정한 속도에 의해 제어되는 합리적인 계획을 알 수 있다.
-----------------------------------------------------------------------------------------------
##### 테스트

1. 테스트 주도 개발
  - 프로그램을 설계하기 전에 먼저 테스트를 설계하면 어떨까? 어떤 함수가 존재하지 않으면 실패하는 테스트를 만든 다음에 프로그램에서 그 함수를 구현하면 어떨까.
  - 처음에 어떤 기능성의 존재 여부를 검사하는 테스트를 작성한 후에 단계적으로 그 기능성을 추가해나가는 것은 어떨까?
  - 일차적이고 명백한 효과는 모든 단일 함수가 그 동작을 검증하는 테스트를 갖게 된다.
  - 이 테스트의 집합은 프로그래머가 기존의 어떤 기능을 부주의하게 망가뜨릴 때마다 그 사실을 알려준다.
  - 테스트를 먼저 작성할 경우 프로그래머가 다른 관점에서 문제를 해결할 수 있다. 프로그래머는 작성할 프로그램을 호출자 관점에서 바라보게 된다. 따라서 함수만큼이나 인터페이스에도 관심을 가져야 한다.
  - 테스트를 먼저 작성함으로써, 프로그래머는 편리하게 호출할 수 있는 소프트웨어를 설계할 수 있다.
  - 문서화로 기능할 수 있다. 어떤 함수를 호출하거나 어떤 객체를 생성하는 방법을 알고 싶을때, 그것의 테스트를 보면 된다.
  - 테스트는 그 코드를 사용하는 방법을 알게 도와주는 예제 집합으로서의 역할을 한다.
2. 테스트 우선 방식의 설계의 예
  - 계획된 프로그래밍(intentional programming) : 자신의 의도를 구현하기 전에, 먼저 그 의도를 가능한 한 단순하고 읽기 편하게 만들어 테스트로 제시한다. 이 단순성과 명쾌함이 바로 프로그램의 좋은 구조를 의미한다고 믿는다.
  - 테스트가 아주 이른 시기에 주요한 설계의 이슈를 명백히 한다는 것이다. 테스트를 먼저 작성하는 것은 설계 의사결정의 차이를 식별하는 것이다.
  - 테스트는 프로그램을 설명하는 컴파일 가능하고 실행 가능한 문서가 된다.
3. 테스트 분리
  - 예제를 통해 이해할것 ( 37p ~ 39 )
4. 운 좋게 얻은 분리
  - 테스트에서 모듈 분리에 대한 필요성은 프로그래머가 프로그램 전체 구조에 이득이 되는 방식으로 분리 작업을 하도록 강제한다.
  - 코드보다 테스트를 먼저 작성하면 설계가 개선된다.
5. 인수 테스트
  - 단위 테스트는 시스템의 개별적인 메커니즘을 검증하는 화이트박스(테스트하는 모듈의 내부 구조를 알고, 그것에 의존하는 테스트) 테스트이다.
  - 인수 테스트는 고객의 요구사항이 충족되고 있는지를 검증하는 블랙박스 테스트(테스트하는 모듈의 내부 구조를 모르고, 그것에 의존하지 않는 테스트)다.
  - 인수테스트는 기능 요소의 궁극적인 문서화 형태이다.
  - 단위테스트가 시스템 내부 요소를 위한 컴파일 가능하고 실행 가능한 문서로서의 역할을 수행하는 것과 마찬가지로
  - 인수테스트는 시스템의 기능 요소를 위한 컴파일 가능하고 실행 가능한 문서로서의 역할을 수행한다.
6. 인수 테스트의 예 (41p~ 43p)
------------------------------------------------------------------------------------

##### refactoring

1. 소프트웨어 모듈에는 세 가지 기능이 있다.
   - 첫 번째는 실행 중에 동작하는 기능으로, 이 기능은 모듈의 존재 이유가 된다.
   - 두 번째는 변경 기능이다. 대부분의 모듈이 생명주기 동안에 변경 과정을 겪게 되고, 가능한 한 간단하게 그런 변경을 할 수 있도록 만들어야 한다.
   - 세 번째 기능은 그것을 읽는 사람과 의사소통하는 기능이다. 모듈은 가독성이 높아야 한다. 가독성이 낮다면 수정이 필요하다
   - 모듈을 읽기 쉽고 변경하기 쉽게 만들려면 무엇이 필요할까? 단순한 원칙과 패턴 이상의 그 무엇이 필요한데, 바로 주의력과 훈련이다.
2. 소수 생성기 : 리팩토링의 예 p46 ~58
