# Agile Design

agile 팀은 각 iteration에서 시스템의 설계를 개선해 지금 그대로도 충분히 좋은 시스템이 되도록 한다.  

미래의 요구사항, 내일 필요한 infrastructure가 아닌, 현재의 시스템 설계에 초점을 두고 더욱 개선하기 위해 노력한다.

## Symptoms of Poor Design 

설계가 잘못됐을때 나타나는 증상을 열거하고 설명한다.  
소프트웨어 프로젝트에서 어떻게 이런 증상이 축적 될 수 있는지  
이것을 피하기 위한 방법이 무엇이 있는지 알아본다  

- Rigidity : The design is hard to change
- Fragility : The design is easy to break
- Immobility : The design is hard to reuse
- Viscosity : Is is hard to do the right thing
- Needless Complexity : Overdesign
- Needless Repetition : Mouse abuse
- Opacity : Disorganized expression

## principle
#### 최적의 설계를 구성할 수 있도록 돕는, 객체 지향 설계 원칙들

1. SRP : Single Responsibility Principle
2. OCP : Open-Closed Principle
3. LSP : Liskov Substituion Principle
4. DIP : Dependency Inversion Principle
5. ISP : Interface Segregation Principle

#### agile 팀은 소프트웨어가 부패하도록 내버려두지 않는다

시스템의 설계를 가능한 한 명료하고 단순하게 유지하고, 이것을 많은 단위 테스트와, 인수 테스트로 뒷받침한다.  
이런 작업을 통해 설계를 유연하고 변형하기 쉬운 것으로 유지할 수 있다.
## SRP (단일 책임 원칙)
cohesion (응집도) : 모듈이나 클래스의 변경을 야기하는 응집력에 대해 얘기해본다.  
## OCP (개방 폐쇄 원칙)
소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

1. 확장에 대해 열려 있다.  
   이것은 모듈의 행위가 확장될 수 있음을 의미한다. 애플리케이션의 요구사항이 변경될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장할 수 있다.  
   즉, 모듈이 하는 일을 변경할 수 있다.  
2. 수정에 대해 닫혀 있다.  
   어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.  

#### 어떤 모듈의 소스 코드를 변경하지 않고도 그 모듈의 행위를 바꾸는 일이 어떻게 가능한가? 어떻게 모듈을 변경하지 않은 채로, 그 모듈이 하는 일을 변경할 수 있을까?
#### 해결책은 추상화다. 모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다. 그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

##### OCP의 예제
Shape class를 추상화하면 -> DrawAllShapes 함수의 행위를 확장하여 새로운 종류의 도형을 그릴 수 있게 만들고 싶다면, Shape 클래스의 새로운 파생 클래스만 만들기만 하면 된다.  
DrawAllShapes 함수를 변경할 필요가 없다. 따라서 DrawAllShapes는 OCP를 따른다.  
이 해결책은 Rigidity(수정되어야 하는 소스 모듈이 없더러, 하나만 제외한다면 재빌드되어야 하는 바이너리 모듈도 없다), Immobility(DrawAllShapes는 Square와 Circle 클래스의 편승 없이도 다른 애플리케이션에서 재사용 될 수 있다) 가 없다.  
즉 이 프로그램은 OCP를 따른다. 기존 코드를 변경하기보다는 새로운 코드를 추가하는 방법으로 변경한다.  
앞의 예는 터무니 없는 소리이다.. Circle은 모두 Square 앞에 그려지도록 결정했다면, DrawAllShapes에서 무슨 일이 일어날까?. DrawAllShapes 함수는 이런 변경에 대해서는 닫혀 있지 않다.  
폐쇄는 완벽할 수 없기 때문에, 전략적이어야 한다. 즉. 설계자는 자신의 설계에서 닫혀 있는 변경의 종류를 선택해야 한다. 가장 그럴 법한 종류의 변경을 추측하고, 그 변경에 대해 보호할 수 있는 추상화를 작성해야 한다.

##### '올가미' 놓기
우리가 놓은 올가미는 종종 틀렸다. 그것이 사용되지 않음에도 불구하고 유지보수되어야 하는 needless Complexity의 악취를 풍겼다.
지나치고 불필요한 추상화로 설계에 부하를 주지 않으려면, 추상화가 실제로 필요할 때 까지 기다렸다가 추상화 하는 것이 낫다.
소프트웨어를 'needless Complexity'의 부하에서 구하려면, 우리 자신이 한번은 총알을 맞을 각오를 해야 한다. 처음에는 코드가 변경되지 않을 것이라 생각하고
작성한다는 뜻이다. 변경이 일어나면, 나중에 일어날 그런 종류의 변경으로부터 보호하는 추상화를 구현한다.

###### 변경 시뮬레이션
테스트를 먼저 작성한다. 테스트를 먼저 작성함으로써, 시스템을 테스트 가능한 것으로 만들 수 있다. 그러므로 테스트 가능한 변경은 나중에 우리를 놀라게 하지 않는다.
우리는 나중에 일어날 다른 종류의 변경으로부터 보호하는 추상화 중 많은 것을 알아차릴 수 있을 것이다.
- 아주 짧은 주기로 개발한다.
- 기반구조보다 기능 요소를 먼저 개발하고, 자주 이 기능 요소를 이해당사자에게 보여준다.
- 가장 중요한 기능 요소를 먼저 개발한다.
- 소프트웨어를 빨리, 그리고 자주 릴리즈한다. 가능한 한 빠르게, 가능한 한 자주 고객과 사용자 앞에서 그것을 시연한다.

##### 명시적인 폐쇄를 위해 추상화 사용하기
첫 번째 총알을 맞았다고 하자. 사용자는 모든 Circle이 Square 앞에 그려지도록 요청 했다.
순서의 변경에 대해 DrawAllShapes 함수를 어떻게 닫을 수 있을까? 폐쇄는 추상화에 기반을 둔다. DrawAllShapes를 순서에 대해 닫으려면
'순서 추상화(ordering abstraction)'가 필요하다. 이 추상화는 표현될 수 있는 가능한 모든 순서 정책을 통해 추상 인터페이스를 제공할 것이다.

##### 폐쇄를 위해 '데이터 주도적' 접근 방식 사용하기.
Shape의 파생 클래스가 서로에 대해 아는 것을 막는다면, 테이블 주도적(table-driven approach) 접근 방식을 사용할 수 있다.
다양한 Shape의 순서에 대해 닫히지 않은 유일한 항목은 테이블 자체뿐이다. 이 테이블은 다른 모든 모듈에서 분리되어 고유한 모듈에 위치할 수 있으므로, 이것에 대한 변경은
다른 모듈에 아무런 영향을 주지 않는다.

##### 결론
많은 면에서 OCP는 객체 지향 설계의 심장이라 할 수 있다. 이 원칙을 따르면 유연성, 재사용성, 유지보수성을 얻을 수 있다.   
하지만 애플리케이션의 모든 부분에 마구 추상화를 적용하는 것도 좋은 생각이 아니다. 프로그램에서 자주 변경되는 부분에만 추상화를 적용하려 노력해야 한다.
어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요하다.

## LSP(Lisko Substitution Principle)

OCP가 내포하는 일차적인 매커니즘은 추상화와 다형성이다. 추상화와 다형성을 지원하는 주요 메커니즘 중 하나가 상속이다.   
##### 리스코프 치환 원칙
타입 S의 객체 o1과ㅏ 타입 T의 객체 o2가 있을 때, T로 프로그램 P를 정의했음에도 불구하고, o1이 o2로 치환될 때 P의 행위가 변하지 않는다면, S는 P의 서브타입이다.  
이 원칙의 중요성은 이것을 위반한 결과를 생각해보면 분명해진다. 

##### OCP 위반을 유발하는 LSP 위반
아무 가상 함수도 포함하지 않는 Shape 클래스를 정의했다. Square와 Circle 클래스는 Shape에서 파생되고 Draw() 함수를 갖지만, Shape에 있는 함수를 오버라이드 하지 않는다.  
Circle과 Square가 Shape를 대체할 수 없기 때문에, DrawShape는 인자로 받는 Shape을 검사하고, 형을 결정하고 나서 적절한 Draw 함수를 호출해야 한다.  
Square와 Circle이 Shape를 대체할 수 없다는 것은 LSP 위반이며, 이 위반은 DrawShape의 OCP 위반을 유발한다. 그러므로 LSP 위반은 잠재적인 OCP 위반이다.


